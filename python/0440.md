题目编号：440

题目：字典序的第K小数字

难度：困难

考察范围：数学、字符串、二分查找

题干：

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

示例：

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。

解题思路：

首先，我们需要了解字典序的概念。字典序是指在字典中的顺序，例如在英文字母表中，a在b的前面，b在c的前面，以此类推。在数字中，1在10的前面，10在100的前面，以此类推。

我们可以将1到n的所有数字按照字典序排序，然后找到第k个数字。但是，这种方法的时间复杂度为O(nlogn)，无法通过本题。

因此，我们需要寻找一种更加高效的方法。我们可以从1开始，依次遍历每个数字，计算它的子树中的数字个数，如果子树中的数字个数小于k，说明第k个数字不在这个子树中，我们需要继续遍历下一个数字。如果子树中的数字个数大于等于k，说明第k个数字在这个子树中，我们需要进入这个子树继续查找。

具体来说，我们可以先计算出当前数字cur和下一个数字next之间的距离distance，如果distance小于k，说明第k个数字在cur的右子树中，我们需要进入右子树继续查找。如果distance大于等于k，说明第k个数字在cur的子树中，我们需要进入cur的子树继续查找。

在进入子树之后，我们需要更新当前数字cur，将cur乘以10，因为在cur的子树中，所有数字的前缀都是cur。同时，我们需要将k减去1，因为我们已经找到了一个数字。

当k减到0时，说明我们已经找到了第k个数字，此时cur就是第k个数字。

解决方案：

```python
class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        cur = 1
        k -= 1
        while k > 0:
            distance = self.getDistance(n, cur, cur + 1)
            if distance <= k:
                cur += 1
                k -= distance
            else:
                cur *= 10
                k -= 1
        return cur

    def getDistance(self, n: int, p: int, q: int) -> int:
        distance = 0
        while p <= n:
            distance += min(n + 1, q) - p
            p *= 10
            q *= 10
        return distance
```

算法复杂度：时间复杂度为O(logn)，空间复杂度为O(1)。