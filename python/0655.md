题目编号：655

题目：输出二叉树

难度：中等

考察范围：二叉树、递归、字符串操作

题干：给定一个二叉树，以字符串形式输出。每个节点用括号括起来，其中包含节点的值和左右子树。空节点用 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

例如，二叉树为：

```
     1
   /   \
  2     3
 / \   / \
4   5 6   7
```

输出为："(1(2(4)(5))(3(6)(7)))"

解题思路：递归

我们可以使用递归的方式来解决这个问题。对于每个节点，我们可以先将其值转换为字符串，然后递归地处理其左右子树。如果当前节点没有左子树但有右子树，那么我们在字符串中保留一个空的左子树的表示。如果当前节点没有右子树但有左子树，我们不需要在字符串中保留右子树的表示。当我们递归地处理完左右子树后，我们将它们加入到当前节点的表示中，得到最终的表示。

解决方案：

```python
class Solution:
    def tree2str(self, t: TreeNode) -> str:
        if not t:
            return ""
        left = self.tree2str(t.left)
        right = self.tree2str(t.right)
        if left == "" and right == "":
            return str(t.val)
        if right == "":
            return str(t.val) + "(" + left + ")"
        return str(t.val) + "(" + left + ")" + "(" + right + ")"
```

算法复杂度：时间复杂度为 O(n)，其中 n 是二叉树中的节点数。在递归时，我们最多访问每个节点一次。空间复杂度为 O(n)，其中 n 是二叉树中的节点数。空间复杂度取决于递归时栈空间的使用情况，最坏情况下，递归需要使用 O(n) 的空间。