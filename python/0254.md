题目编号：254

题目：因子的组合

难度：中等

考察范围：数学、回溯算法

题干：

整数可以被看作是其因子的乘积。

例如：

8 = 2 x 2 x 2;
  = 2 x 4.

请实现一个函数，该函数接收一个整数 n 并返回该整数所有的因子组合。

注意：

1. 你可以假定 n 为永远为正数。
2. 因子必须大于 1 并且小于 n。

示例 1：

输入: 1
输出: []

示例 2：

输入: 37
输出: []

示例 3：

输入: 12
输出:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]

示例 4：

输入: 32
输出:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]

解题思路：

这道题可以使用回溯算法来解决。回溯算法是一种通过穷举所有可能情况来找到所有解的算法。在回溯算法中，我们需要定义一个递归函数，该函数用于搜索所有可能的因子组合。在递归函数中，我们需要定义一个变量来记录当前搜索到的因子，以及一个变量来记录当前搜索到的因子的乘积。在每次递归中，我们需要枚举所有可能的因子，如果当前因子可以整除 n 并且大于等于上一个因子，那么我们就将其加入到当前搜索到的因子中，并将其乘积加入到当前搜索到的因子的乘积中。如果当前搜索到的因子的乘积等于 n，那么我们就将当前搜索到的因子加入到结果中。否则，我们就继续递归搜索下一个因子。

解决方案：

```python
class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        def dfs(n, start, path, res):
            if n == 1:
                if len(path) > 1:
                    res.append(path[:])
                return
            for i in range(start, n + 1):
                if i > n // i:
                    break
                if n % i == 0:
                    path.append(i)
                    dfs(n // i, i, path, res)
                    path.pop()
            path.append(n)
            dfs(1, n, path, res)
            path.pop()

        res = []
        dfs(n, 2, [], res)
        return res
```

算法复杂度：时间复杂度为 O(2^n)，空间复杂度为 O(n)。