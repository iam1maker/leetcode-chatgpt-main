题目编号：750

题目：随机翻转矩阵

难度：中等

考察范围：随机化、数组

题干：给定一个二维矩阵，其中每个元素都是 0 或 1。我们可以将任何一行的值反转，也可以将任何一列的值反转。我们想要执行这样的步骤使每个行的值都以非递减的顺序排列，每个列的值也以非递减的顺序排列。返回达成这个目标所需的最小反转次数。如果已经按要求排列，那么返回 0。

解题思路：首先，我们需要明确一点，对于一个矩阵，如果我们确定了其中一行或一列的状态，那么整个矩阵的状态也就确定了。因此，我们可以先将矩阵的每一行都变成非递减的状态，然后再将每一列都变成非递减的状态。

对于每一行，我们可以先判断它是否已经是非递减的状态，如果是，就不需要进行任何操作；如果不是，我们可以将这一行翻转，使其变成非递减的状态。具体来说，我们可以统计这一行中 0 和 1 的个数，然后根据它们的数量关系来决定是否需要翻转这一行。

对于每一列，我们可以采用类似的方法。具体来说，我们可以先将矩阵转置，然后对每一行进行操作，最后再将矩阵转置回来。

解决方案：

```python
class Solution:

    def minFlipsMonoIncr(self, S: str) -> int:
        n = len(S)
        # 统计 0 和 1 的数量
        zeros = [0] * (n + 1)
        ones = [0] * (n + 1)
        for i in range(n):
            zeros[i+1] = zeros[i] + (S[i] == '0')
            ones[i+1] = ones[i] + (S[i] == '1')
        # 初始化结果
        res = float('inf')
        # 枚举分界点
        for i in range(n+1):
            # 将左边的 0 全部变成 1，将右边的 1 全部变成 0
            flips = zeros[i] + ones[n] - ones[i]
            res = min(res, flips)
        return res
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。