题目编号：776

题目：拆分二叉搜索树

难度：中等

考察范围：二叉搜索树、递归

题干：

给你一棵二叉搜索树（BST）、它的根结点 root 以及目标值 V。

请你分割该二叉搜索树，使得左边子树节点的值都小于等于目标值 V，右边子树节点的值都大于等于目标值 V，并且新的两棵子树节点数量尽可能相等。

你需要输出新二叉搜索树的根结点。如果树的节点数少于 2，就不能按照上述方式来分割二叉搜索树。因此，你应该返回原始的二叉搜索树 [原题链接](https://leetcode-cn.com/problems/split-bst/)

解题思路：

题目要求我们将二叉搜索树分成两个子树，使得左边子树节点的值都小于等于目标值 V，右边子树节点的值都大于等于目标值 V，并且新的两棵子树节点数量尽可能相等。

我们可以通过递归的方式来解决这个问题。首先，我们需要判断根节点的值与目标值 V 的大小关系，如果根节点的值小于等于目标值 V，那么根节点及其左子树都可以放到左边的子树中，右子树则需要递归处理；如果根节点的值大于目标值 V，那么根节点及其右子树都可以放到右边的子树中，左子树则需要递归处理。

需要注意的是，如果根节点的值等于目标值 V，那么我们需要将根节点分配到左边的子树中，因为题目要求左边子树节点的值都小于等于目标值 V。

解决方案：

```python
class Solution:
    def splitBST(self, root: TreeNode, V: int) -> List[TreeNode]:
        if not root:
            return [None, None]
        if root.val <= V:
            res = self.splitBST(root.right, V)
            root.right = res[0]
            return [root, res[1]]
        else:
            res = self.splitBST(root.left, V)
            root.left = res[1]
            return [res[0], root]
```

算法复杂度：时间复杂度为 O(logN)，其中 N 为二叉搜索树的节点数，因为每次递归都会将树的节点数减半；空间复杂度为 O(logN)，因为递归的深度为树的高度，最坏情况下树的高度为 N。