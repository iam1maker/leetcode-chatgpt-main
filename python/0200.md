题目编号：200

题目：岛屿数量

难度：中等

考察范围：深度优先搜索、广度优先搜索、并查集

题干：

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接而成。

此外，你可以假设该网格的四条边均被水包围。

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

示例 2：

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3

解题思路：

本题可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来解决。我们可以遍历整个二维网格，当遇到一个为 '1' 的格子时，就将其与相邻的所有 '1' 格子都标记为已访问过的格子，这样就可以将整个岛屿都遍历完毕。遍历过程中，我们可以使用一个计数器来记录岛屿的数量。

解决方案：

使用深度优先搜索（DFS）来解决本题：

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(grid, i, j):
            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
                return
            grid[i][j] = '0'
            dfs(grid, i-1, j)
            dfs(grid, i+1, j)
            dfs(grid, i, j-1)
            dfs(grid, i, j+1)
        
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    count += 1
                    dfs(grid, i, j)
        return count
```

算法复杂度：时间复杂度为 O(mn)，其中 m 和 n 分别为二维网格的行数和列数；空间复杂度为 O(mn)，最坏情况下，整个网格均为陆地，递归的深度达到 mn。