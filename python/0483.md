题目编号：483

题目：最小好进制

难度：困难

考察范围：数学、二分查找

题干：

对于给定的整数 n，如果n的k（k>=2）进制数的所有数位全都是1，则称k（k>=2）是 n 的一个好进制。

以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。

示例 1：

输入："13"
输出："3"
解释：13 的 3 进制是 111。

示例 2：

输入："4681"
输出："8"
解释：4681 的 8 进制是 11111。

示例 3：

输入："1000000000000000000"
输出："999999999999999999"
解释：1000000000000000000 的 999999999999999999 进制是 11。

解题思路：

题目要求找到最小的好进制，可以使用二分查找来解决。

假设 n 的最小好进制为 k，那么有：

n = 1 + k + k^2 + ... + k^{m-1}

其中，m 为 k 进制下 n 的位数。

根据等比数列求和公式，上式可以化简为：

n = \frac{k^m - 1}{k - 1}

移项得：

k^m - n k + n - 1 = 0

这是一个关于 k 的一元 m 次方程，可以使用二分查找来求解。

具体来说，我们可以枚举 m，然后在 [2, n] 的范围内二分查找 k，使得上式成立。如果找到了一个 k，使得上式成立，那么就可以更新答案。

解决方案：

```python
class Solution:
    def smallestGoodBase(self, n: str) -> str:
        n = int(n)
        # 枚举 m，m 的最大值为 log2(n) + 1
        for m in range(int(math.log2(n)) + 1, 1, -1):
            # 在 [2, n] 的范围内二分查找 k
            left, right = 2, n - 1
            while left <= right:
                mid = (left + right) // 2
                # 计算等比数列和
                s = (mid ** m - 1) // (mid - 1)
                if s == n:
                    return str(mid)
                elif s < n:
                    left = mid + 1
                else:
                    right = mid - 1
        # 如果没有找到合法的 k，返回 n - 1
        return str(n - 1)
```

算法复杂度：时间复杂度为 O(log^2 n)，空间复杂度为 O(1)。