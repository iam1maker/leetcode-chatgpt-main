题目编号：801

题目：使序列递增的最小交换次数

难度：中等

考察范围：贪心算法、动态规划

题干：给定一个长度为 n 的整数序列，你需要找到一个最小的交换次数，使得交换任意两个元素后，序列变得递增。

解题思路：本题可以使用贪心算法或动态规划来解决。这里介绍一种贪心算法的思路。

首先，我们需要明确一点，即对于一个递增的序列，任意两个元素交换后，序列仍然是递增的。因此，我们可以将原序列中的每个元素与其在递增序列中的位置进行比较，如果位置不同，则需要进行交换。

具体来说，我们可以使用一个字典来记录每个元素在原序列中的位置，然后对原序列进行排序，得到一个递增序列。接着，我们遍历递增序列，对于每个元素，如果其在原序列中的位置与递增序列中的位置不同，则需要进行交换。交换后，我们需要更新字典中对应元素的位置信息。

最终，我们得到的交换次数即为所求的最小交换次数。

解决方案：

```python
def minSwap(nums: List[int]) -> int:
    n = len(nums)
    # 记录每个元素在原序列中的位置
    pos = {num: i for i, num in enumerate(nums)}
    # 对原序列进行排序，得到递增序列
    sorted_nums = sorted(nums)
    # 记录递增序列中每个元素在原序列中的位置
    sorted_pos = {num: pos[num] for num in sorted_nums}
    # 初始化交换次数为 0
    cnt = 0
    # 遍历递增序列，对于每个元素，如果其在原序列中的位置与递增序列中的位置不同，则需要进行交换
    for i in range(n):
        if nums[i] != sorted_nums[i]:
            # 找到需要交换的元素
            j = sorted_pos[nums[i]]
            # 交换元素
            nums[i], nums[j] = nums[j], nums[i]
            # 更新字典中对应元素的位置信息
            pos[nums[i]], pos[nums[j]] = i, j
            # 更新交换次数
            cnt += 1
    return cnt
```

算法复杂度：本算法的时间复杂度为 O(n\log n)，其中 n 是序列的长度。排序的时间复杂度为 O(n\log n)，遍历序列的时间复杂度为 O(n)。空间复杂度为 O(n)，需要使用一个字典来记录每个元素在原序列中的位置。