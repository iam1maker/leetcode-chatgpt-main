题目编号：581

题目：最短无序连续子数组

难度：中等

考察范围：数组、排序

题干：给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。你找到的子数组应是最短的，请输出它的长度。

解题思路：首先，我们需要找到无序子数组的左右边界。我们可以从左到右遍历数组，记录当前最大值 max，如果当前值小于 max，则说明当前值不在正确的位置上，需要进行排序，因此更新右边界 r。同理，我们也可以从右到左遍历数组，记录当前最小值 min，如果当前值大于 min，则说明当前值不在正确的位置上，需要进行排序，因此更新左边界 l。最后，无序子数组的长度即为 r-l+1。

解决方案：

```python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 1:
            return 0
        l, r = n-1, 0
        max_val, min_val = nums[0], nums[-1]
        for i in range(n):
            if nums[i] < max_val:
                r = i
            else:
                max_val = nums[i]
            if nums[n-i-1] > min_val:
                l = n-i-1
            else:
                min_val = nums[n-i-1]
        return r-l+1 if r > l else 0
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。