题目编号：751

题目：IP 到 CIDR

难度：中等

考察范围：位运算、数学

题干：

给定一个起始 IP 地址 ip 和一个我们需要包含的 IP 的数量 n，返回用列表（最小可能的长度）表示的 CIDR块的范围。

CIDR 块是一个用于 CIDR 编址方案的地址块，它由一个 IP 地址和前缀长度表示。前缀长度指的是地址中前缀中 1 的数量，例如，前缀长度为 32 的地址表示为 255.255.255.255/32。每个组件都是一个整数，范围为 [0, 255]。

例如，CIDR 块 "123.45.67.89/20" 表示地址范围为从 123.45.64.0 到 123.45.79.255。

我们采用“类似于打印机”的风格，其中最后一个数字表示为打印机中的“掩码位数”。例如，CIDR 块 123.45.67.64/26 表示为 "123.45.67.64/26"。

如果两个 CIDR 块有公共前缀，则可以将它们合并为一个较大的块。

示例 1：

输入：ip = "255.0.0.7", n = 10
输出：["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
解释：
转换为二进制时，初始IP地址为 11111111 00000000 00000000 00000111，前缀长度为 32。
前缀长度为 k 的 CIDR 块的范围为 [x, x + 2^(32-k)]，其中 x 是前缀为 k 的 CIDR 块的起始地址。
第一个 CIDR 块的范围为 [255.0.0.7, 255.0.0.7 + 2^(32-32) - 1] = [255.0.0.7, 255.0.0.7]，即 "255.0.0.7/32"。
第二个 CIDR 块的范围为 [255.0.0.8, 255.0.0.8 + 2^(32-29) - 1] = [255.0.0.8, 255.0.0.15]，即 "255.0.0.8/29"。
第三个 CIDR 块的范围为 [255.0.0.16, 255.0.0.16 + 2^(32-32) - 1] = [255.0.0.16, 255.0.0.16]，即 "255.0.0.16/32"。

解题思路：

题目要求我们将一个 IP 地址和一个数量 n 转换成 CIDR 块的形式。我们可以先将 IP 地址转换成二进制形式，然后根据前缀长度 k，计算出 CIDR 块的范围。

对于一个前缀长度为 k 的 CIDR 块，其范围为 [x, x + 2^(32-k)]，其中 x 是前缀为 k 的 CIDR 块的起始地址。因此，我们可以通过不断地将 n 减去当前 CIDR 块的 IP 数量，来计算出下一个 CIDR 块的起始地址和前缀长度。

在计算下一个 CIDR 块的前缀长度时，我们需要注意以下几点：

1. 如果当前 CIDR 块的 IP 数量已经大于等于 n，那么我们就不需要再继续计算下去了。

2. 如果当前 CIDR 块的前缀长度已经达到了 32，那么我们也不需要再继续计算下去了。

3. 如果当前 CIDR 块的前缀长度加上 1 后，其 IP 数量已经大于 n，那么我们就需要将前缀长度加 1，以减少 CIDR 块的数量。

4. 如果当前 CIDR 块的前缀长度加上 1 后，其 IP 数量仍然小于等于 n，那么我们就需要将前缀长度加 1，以增加 CIDR 块的数量。

解决方案：

```python
class Solution:
    def ipToCIDR(self, ip: str, n: int) -> List[str]:
        # 将 IP 地址转换成整数形式
        def ipToInt(ip: str) -> int:
            res = 0
            for x in ip.split('.'):
                res = res * 256 + int(x)
            return res

        # 将整数形式的 IP 地址转换成字符串形式
        def intToIp(x: int) -> str:
            return '.'.join(str((x >> i) % 256) for i in (24, 16, 8, 0))

        res = []
        start = ipToInt(ip)
        while n > 0:
            # 计算当前 CIDR 块的前缀长度
            mask = max(33 - (start & -start).bit_length(), 33 - n.bit_length())
            # 计算当前 CIDR 块的 IP 数量
            count = 1 << (32 - mask)
            # 如果当前 CIDR 块的 IP 数量大于 n，那么我们需要将前缀长度加 1
            if count > n:
                mask -= 1
                count //= 2
            # 将当前 CIDR 块加入结果列表中
            res.append(intToIp(start) + '/' + str(mask))
            # 更新下一个 CIDR 块的起始地址和 IP 数量
            start += count
            n -= count
        return res
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。