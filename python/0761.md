题目编号：761

题目：特殊的二进制序列

难度：困难

考察范围：字符串、递归

题干：

特殊的二进制序列是具有以下两个性质的二进制序列：

0 的数量与 1 的数量相等。
二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。
给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)

在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？

示例 1:

输入: S = "11011000"
输出: "11100100"
解释:
将子串 "10" （在S[1]出现） 和子串 "1100"（在S[3]出现）进行交换。
这是在进行若干次操作后按字典序排列最大的结果。

说明:

S 的长度不超过 50。
S 保证为一个满足上述定义的特殊 的二进制序列。

解题思路：

题目要求我们将特殊的二进制序列按照字典序排列的最大的结果，那么我们可以先将特殊的二进制序列进行拆分，然后对每个子串进行递归处理，最后将子串按照字典序排列后进行拼接即可。

具体来说，我们可以将特殊的二进制序列拆分成若干个特殊的二进制序列，然后对每个子串进行递归处理，最后将子串按照字典序排列后进行拼接即可。

对于一个特殊的二进制序列，我们可以将其拆分成若干个特殊的二进制序列，然后对每个子串进行递归处理，最后将子串按照字典序排列后进行拼接即可。

具体来说，我们可以先统计出每个特殊的二进制序列的长度，然后将其按照长度从大到小排序，这样可以保证在拼接子串时，长度更长的子串排在前面，从而保证字典序最大。

然后对于每个特殊的二进制序列，我们可以将其拆分成若干个特殊的二进制序列，然后对每个子串进行递归处理，最后将子串按照字典序排列后进行拼接即可。

解决方案：

```python
class Solution:
    def makeLargestSpecial(self, S: str) -> str:
        def dfs(s):
            if not s:
                return ''
            cnt, i, res = 0, 0, []
            for j, ch in enumerate(s):
                cnt += 1 if ch == '1' else -1
                if cnt == 0:
                    res.append('1' + dfs(s[i+1:j]) + '0')
                    i = j + 1
            return ''.join(sorted(res, reverse=True))
        return dfs(S)
```

算法复杂度：O(n^2)

其中，n为特殊的二进制序列的长度。在递归处理每个子串时，最坏情况下需要遍历整个子串，因此时间复杂度为O(n^2)。