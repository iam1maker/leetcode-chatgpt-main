题目编号：891

题目：子序列宽度之和

难度：困难

考察范围：动态规划、数学

题干：

给定一个整数数组 A ，考虑 A 的所有非空子序列。

对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。

返回 A 的所有子序列的宽度之和。

由于答案可能非常大，请返回答案模 10^9+7。

示例：

输入：[2,1,3]
输出：6
解释：
子序列为 [2]，[1]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。
相应的宽度是 0，0，0，1，1，2，2 。
这些宽度之和是 6 。

提示：

1 <= A.length <= 20000
1 <= A[i] <= 20000

解题思路：

首先，我们可以将数组 A 排序，这样最大值和最小值就很容易得到了。

然后，我们考虑对于每个数 A[i]，它在多少个子序列中是最大值或最小值。

对于最大值，它必须是子序列中的最后一个元素，而其他元素可以是任意的。因此，对于 A[i]，它在 2^(i-1) 个子序列中是最大值。

同理，对于最小值，它必须是子序列中的第一个元素，而其他元素可以是任意的。因此，对于 A[i]，它在 2^(n-i) 个子序列中是最小值。

最后，我们将每个数的贡献相加即可。

解决方案：

```python
class Solution:
    def sumSubseqWidths(self, A: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(A)
        A.sort()
        ans = 0
        pow2 = [1]
        for i in range(1, n):
            pow2.append(pow2[-1] * 2 % MOD)
        for i in range(n):
            ans = (ans + (pow2[i] - pow2[n-i-1]) * A[i]) % MOD
        return ans
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。