题目编号：375

题目：猜数字大小 II

难度：中等

考察范围：动态规划

题干：

我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，才算游戏结束。

例如，n = 10，我选择了8。

你猜测 5，我会告诉你，我选的数字比你的小了，你需要支付 5 元。

你猜测 7，我会告诉你，我选的数字比你的大了，你需要支付 7 元。

你猜测 9，我会告诉你，我选的数字比你的大了，你需要支付 9 元。

你猜测 8，我选的数字，游戏结束。

你最终需要支付 5 + 7 + 9 = 21 元。

给你一个数字 n ，返回你最少需要支付多少钱才能确保你能赢得这个游戏。

解题思路：

这是一道动态规划的题目，我们可以用 dp[i][j] 表示从数字 i 到 j 中猜出正确数字的最小花费。

对于每个 dp[i][j]，我们枚举它可能猜的数字 x，其中 i <= x <= j，然后可以知道选择 x 之后，可能出现的情况有两种：

1. 如果我们猜的数字比正确答案小，那么我们需要在 x+1 到 j 的范围内寻找答案，此时最小花费为 dp[x+1][j]。

2. 如果我们猜的数字比正确答案大，那么我们需要在 i 到 x-1 的范围内寻找答案，此时最小花费为 dp[i][x-1]。

由于我们不知道正确答案是多少，因此我们需要把两种情况下的最小花费取一个最小值，然后加上猜测数字 x 的花费 x，就是 dp[i][j] 的值了。

最终的答案就是 dp[1][n]。

解决方案：

```python
class Solution:
    def getMoneyAmount(self, n: int) -> int:
        dp = [[0] * (n+1) for _ in range(n+1)]
        for i in range(n, 0, -1):
            for j in range(i+1, n+1):
                dp[i][j] = min(x + max(dp[i][x-1], dp[x+1][j]) for x in range(i, j))
        return dp[1][n]
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。