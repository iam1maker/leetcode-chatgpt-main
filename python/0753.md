题目编号：753

题目：破解保险箱

难度：困难

考察范围：深度优先搜索、图论

题干：你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有 10 个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。

列表 deadends 包含了一组死亡数字，这些数字将会被视为 "禁止" 的数字。如果字符串 "0000" 已经被锁定，则无法再旋转该锁，因为 "0000" 是死亡数字之一。

编写一个函数，来判断是否能够解开锁，如果可以，则返回最少需要旋转几次才能解开；如果不能，则返回 -1。

解题思路：本题可以使用深度优先搜索算法来解决。从初始状态 "0000" 开始，每次旋转一个拨轮，得到新的状态，如果新状态不在死亡数字中，就将其加入队列中，继续搜索。直到找到目标状态或者队列为空。

解决方案：

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        # 将死亡数字转换为集合，方便查找
        dead = set(deadends)
        # 如果初始状态就是死亡数字，直接返回-1
        if "0000" in dead:
            return -1
        # 初始化队列，将初始状态加入队列
        queue = collections.deque(["0000"])
        # 初始化步数为0
        step = 0
        # 开始搜索
        while queue:
            # 遍历当前队列中的所有状态
            for _ in range(len(queue)):
                # 取出队列中的状态
                cur = queue.popleft()
                # 如果当前状态是目标状态，返回步数
                if cur == target:
                    return step
                # 如果当前状态在死亡数字中，跳过
                if cur in dead:
                    continue
                # 将当前状态的所有相邻状态加入队列
                for i in range(4):
                    # 将当前状态的第i个拨轮向上旋转一位
                    up = cur[:i] + str((int(cur[i]) + 1) % 10) + cur[i+1:]
                    # 将当前状态的第i个拨轮向下旋转一位
                    down = cur[:i] + str((int(cur[i]) - 1) % 10) + cur[i+1:]
                    # 将新状态加入队列
                    queue.append(up)
                    queue.append(down)
                # 将当前状态标记为已访问
                dead.add(cur)
            # 增加步数
            step += 1
        # 如果队列为空，说明无法解锁，返回-1
        return -1
```

算法复杂度：时间复杂度为 O(10^4)，空间复杂度为 O(10^4)。