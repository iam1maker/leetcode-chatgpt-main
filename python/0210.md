题目编号：210

题目：课程表 II

难度：中等

考察范围：图论、拓扑排序

题干：

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

示例 1:

输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。

示例 2:

输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。

解题思路：

本题是一道典型的拓扑排序问题，我们可以使用拓扑排序的思想来解决。

拓扑排序的基本思想是，每次选择入度为 0 的节点，将其从图中删除，并将与其相邻的节点的入度减 1。重复此操作，直到所有节点均被删除或无法删除。

具体实现时，我们使用一个队列来存储所有入度为 0 的节点，每次取出队首节点 u，将它的所有相邻节点的入度减 1，如果相邻节点 v 的入度为 0，则将 v 加入队列中。在每次取出队首节点时，将节点加入答案中，直到队列为空。如果答案中包含的节点数不足 n 个，则说明存在环，返回空列表。

解决方案：

```python
from typing import List
from collections import deque

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # 初始化入度数组和邻接表
        in_degree = [0] * numCourses
        adj = [[] for _ in range(numCourses)]
        # 构建邻接表和入度数组
        for cur, pre in prerequisites:
            in_degree[cur] += 1
            adj[pre].append(cur)
        # 将所有入度为 0 的节点加入队列
        q = deque([i for i in range(numCourses) if in_degree[i] == 0])
        res = []
        # 每次取出队首节点，将其所有相邻节点的入度减 1
        while q:
            u = q.popleft()
            res.append(u)
            for v in adj[u]:
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    q.append(v)
        # 如果答案中包含的节点数不足 n 个，则说明存在环，返回空列表
        return res if len(res) == numCourses else []
```

算法复杂度：时间复杂度为 O(n+m)，其中 n 是课程数，m 是先决条件的数量。遍历一次邻接表需要 O(m) 的时间，遍历一次入度数组需要 O(n) 的时间，因此总时间复杂度为 O(n+m)。空间复杂度为 O(n+m)，需要使用邻接表和入度数组来存储图的信息，以及使用队列来进行拓扑排序。