题目编号：153

题目：寻找旋转排序数组中的最小值

难度：中等

考察范围：数组、二分查找

题干：

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

(例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2])。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:

输入: [3,4,5,1,2]
输出: 1

示例 2:

输入: [4,5,6,7,0,1,2]
输出: 0

解题思路：

题目要求找到旋转排序数组中的最小值，可以使用二分查找的思想来解决。

首先，我们需要找到旋转点，也就是数组中最小的元素。我们可以使用二分查找的思想来寻找旋转点。

具体思路如下：

1. 定义左右指针，分别指向数组的起始和末尾位置。

2. 计算中间位置 mid = (left + right) // 2。

3. 如果 nums[mid] > nums[right]，说明最小值在右半部分，将 left 指针移动到 mid + 1。

4. 如果 nums[mid] < nums[right]，说明最小值在左半部分或者就是 mid，将 right 指针移动到 mid。

5. 重复步骤 2-4，直到 left == right，此时的值就是旋转点。

找到旋转点后，最小值就是旋转点的下一个元素。

解决方案：

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

算法复杂度：

时间复杂度：O(log n)，其中 n 是数组的长度。二分查找的时间复杂度为 O(log n)。

空间复杂度：O(1)。我们只需要常数级别的空间存放变量。