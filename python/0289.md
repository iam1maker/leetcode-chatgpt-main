题目编号：289

题目：生命游戏

难度：中等

考察范围：数组、模拟

题干：

根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个由 0 和 1 组成的二维网格，其中 0 表示死亡，1 表示生存。每个单元格都与其八个相邻位置（水平，垂直，对角线）中的单元格形成关系。按照以下规则更新网格：

- 任何活着的单元格，如果周围八个单元格中有两个或三个单元格为活着的，则继续活着。
- 任何活着的单元格，如果周围八个单元格中有超过三个单元格为活着的，则死亡。
- 任何死亡的单元格，如果周围八个单元格中恰好有三个单元格为活着的，则变成活着的状态。

下面是一个初始状态为 [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] 的示例。

```
输入：
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
```

解题思路：

本题是一道模拟题，需要根据题目中的规则模拟每个细胞的状态变化。由于题目中要求同时更新所有细胞的状态，因此需要使用一个额外的数组来存储更新后的状态，最后再将其复制回原数组。

对于每个细胞，需要统计其周围八个细胞中活着的数量，根据题目中的规则进行状态更新。

解决方案：

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m, n = len(board), len(board[0])
        # 定义方向数组，用于统计周围细胞的状态
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]
        # 复制原数组
        new_board = [[board[i][j] for j in range(n)] for i in range(m)]
        # 遍历每个细胞
        for i in range(m):
            for j in range(n):
                # 统计周围细胞中活着的数量
                live_count = 0
                for d in directions:
                    x, y = i + d[0], j + d[1]
                    if x >= 0 and x < m and y >= 0 and y < n and new_board[x][y] == 1:
                        live_count += 1
                # 根据规则更新状态
                if new_board[i][j] == 1 and (live_count < 2 or live_count > 3):
                    board[i][j] = 0
                elif new_board[i][j] == 0 and live_count == 3:
                    board[i][j] = 1

```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。其中 m 和 n 分别为数组的行数和列数。