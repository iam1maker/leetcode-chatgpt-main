题目编号：798

题目：得分最高的最小轮调

难度：困难

考察范围：贪心算法、二分查找

题干：

给定一个数组 A，我们可以将它按一个非负整数 K 进行轮调，这样每个索引对应的值就变成了原数组上移动 K 个位置后的新值（索引为 0 的位置移动到索引为 K % A.length 的位置，索引为 1 的位置移动到索引为 (K + 1) % A.length 的位置，以此类推，每个位置移动后都保持在数组中）。

我们定义数组 A 的“轮调值” A[i] * i 的总和最大化（0 <= i < A.length）。

返回数组中的最大“轮调值”。

解题思路：

本题需要求出数组 A 的最大“轮调值”，可以考虑贪心算法。我们可以将 A 中的元素按照从大到小的顺序排序，然后依次将每个元素放到对应的位置上，计算出每次放置后的“轮调值”，最后将所有“轮调值”相加即可。

但是，这种贪心算法并不是最优解。我们可以使用二分查找来优化算法。具体来说，我们可以二分查找“轮调值”的最大值，然后判断是否存在一种轮调方案，使得“轮调值”大于等于这个最大值。如果存在这样的轮调方案，则说明最大“轮调值”不小于这个最大值；否则，最大“轮调值”一定小于这个最大值。

解决方案：

```python
class Solution:
    def maxRotateFunction(self, A: List[int]) -> int:
        n = len(A)
        s = sum(A)
        f = sum(i * A[i] for i in range(n))
        ans = f
        for i in range(1, n):
            f += s - n * A[n - i]
            ans = max(ans, f)
        return ans
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。