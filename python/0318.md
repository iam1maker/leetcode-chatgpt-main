题目编号：318

题目：最大单词长度乘积

难度：中等

考察范围：位运算、字符串

题干：

给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，其中两个单词不重叠，即 i != j。你可以认为所有字符串都只包含小写字母。如果不存在这样的两个单词，则返回 0。

示例 1:

输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "xtfn"。

示例 2:

输入: ["a","ab","abc","d","cd","bcd","abcd"]
输出: 4 
解释: 这两个单词为 "ab", "cd"。

示例 3:

输入: ["a","aa","aaa","aaaa"]
输出: 0 
解释: 不存在这样的两个单词。

解题思路：

本题需要找到两个单词的长度乘积的最大值，因此需要遍历所有的单词对，计算它们的长度乘积，并找到最大值。但是，如果直接计算长度乘积，时间复杂度会达到 O(n^2 * k^2)，其中 n 是单词个数，k 是单词的平均长度，这样的时间复杂度是无法接受的。

因此，我们需要寻找一种更快的方法来计算两个单词的长度乘积。注意到题目中只包含小写字母，因此可以使用一个 32 位的整数来表示一个单词中出现的字母。具体地，将每个字母看作一个二进制位，如果该字母出现在单词中，则将对应的二进制位置为 1，否则为 0。例如，对于单词 "abc"，可以用二进制数 00000000000000000000000000000111 来表示。

这样，两个单词的长度乘积就可以通过它们的二进制数进行位运算得到。如果两个单词没有重复的字母，则它们的二进制数进行按位与运算的结果为 0，否则结果不为 0。因此，我们可以先将所有单词的二进制数计算出来，并存储在一个数组中，然后遍历所有单词对，计算它们的长度乘积，并进行按位与运算，找到最大值即可。

解决方案：

```python
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n = len(words)
        masks = [0] * n
        lens = [0] * n
        for i in range(n):
            mask = 0
            for c in words[i]:
                mask |= 1 << (ord(c) - ord('a'))
            masks[i] = mask
            lens[i] = len(words[i])
        max_product = 0
        for i in range(n):
            for j in range(i + 1, n):
                if masks[i] & masks[j] == 0:
                    max_product = max(max_product, lens[i] * lens[j])
        return max_product
```

算法复杂度：时间复杂度为 O(n^2)，其中 n 是单词个数。遍历所有单词对需要 O(n^2) 的时间，计算每个单词的二进制数需要 O(k) 的时间，其中 k 是单词的平均长度。空间复杂度为 O(n)，需要存储每个单词的二进制数和长度。