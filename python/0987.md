题目编号：987

题目：二叉树的垂序遍历

难度：困难

考察范围：二叉树、遍历、排序

题干：

给定二叉树，按垂序遍历返回其结点值。

对位于 (x, y) 的每个结点而言，其左右子结点分别位于 (x-1, y-1) 和 (x+1, y-1)。

把一条垂线从 x = -infinity 移动到 x = +infinity ，每当该垂线与结点接触时，我们按从上到下的顺序报告结点的值（即 y 坐标递减）。

如果两个结点位置相同，则首先报告的结点值较小。

按 x 坐标顺序返回非空报告。即，按 x 坐标顺序返回答案列表。其中每个报告都有一个结点值列表。

示例 1：

输入：[3,9,20,null,null,15,7]
输出：[[9],[3,15],[20],[7]]
解释：
在不丧失一般性的情况下，我们可以假设根结点位于 (0, 0)：
然后，值为 9 的结点出现在 (-1, -1)；
值为 3 和 15 的两个结点分别出现在 (0, 0) 和 (0, -2)；
值为 20 的结点出现在 (1, -1)；
值为 7 的结点出现在 (2, -2)。
示例 2：

输入：[1,2,3,4,5,6,7]
输出：[[4],[2],[1,5,6],[3],[7]]
解释：
根据给定的方案，值为 5 和 6 的两个结点出现在同一位置。
然而，在报告 "[1,5,6]" 中，结点值 5 排在前面。
 

提示：

树的结点数介于 1 和 1000 之间。
每个结点值介于 0 和 1000 之间。

解题思路：

本题需要按照垂序遍历的方式遍历二叉树，然后按照题目要求进行排序输出。

垂序遍历的方式可以使用 BFS 进行遍历，每个节点记录其坐标信息，然后按照坐标信息进行排序输出即可。

解决方案：

```python
class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        # 定义一个字典，用于存储每个节点的坐标信息
        node_dict = {}
        # 定义一个队列，用于 BFS 遍历二叉树
        queue = [(root, 0, 0)]
        # BFS 遍历二叉树
        while queue:
            # 取出队列中的第一个节点
            node, x, y = queue.pop(0)
            # 将节点的坐标信息存储到字典中
            if x in node_dict:
                node_dict[x].append((y, node.val))
            else:
                node_dict[x] = [(y, node.val)]
            # 将节点的左右子节点加入队列中
            if node.left:
                queue.append((node.left, x-1, y-1))
            if node.right:
                queue.append((node.right, x+1, y-1))
        # 对字典中的每个节点的坐标信息进行排序
        res = []
        for x in sorted(node_dict.keys()):
            res.append([val for y, val in sorted(node_dict[x])])
        return res
```

算法复杂度：时间复杂度为 O(nlogn)，其中 n 为二叉树的节点数，主要是对字典中的每个节点的坐标信息进行排序；空间复杂度为 O(n)，主要是存储每个节点的坐标信息。