题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：

你的音乐播放器里有 `n` 首不同的歌，在旅途中，你的旅伴想要听 `m` 首歌（不一定不同，即，允许重复歌曲）。请你为她按如下规则创建一个播放列表：

每首歌都至少播放一次。
一首歌只有在其他 `k` 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 `10^9 + 7` 的结果。

解题思路：

这是一道动态规划的题目，我们可以定义 `dp[i][j]` 表示播放列表中有 `i` 首歌，其中有 `j` 首歌已经播放过了，那么我们需要考虑两种情况：

1. 当前这首歌是新的歌曲，那么我们可以从 `dp[i-1][j-1]` 转移过来，表示在播放列表中加入这首新歌。

2. 当前这首歌是已经播放过的歌曲，那么我们可以从 `dp[i-1][j]` 转移过来，表示在播放列表中加入这首已经播放过的歌曲。

最终的答案就是 `dp[m][n]`。

解决方案：

```python
class Solution:
    def numMusicPlaylists(self, n: int, m: int, k: int) -> int:
        mod = 10**9 + 7
        dp = [[0] * (n+1) for _ in range(m+1)]
        dp[0][0] = 1
        for i in range(1, m+1):
            for j in range(1, n+1):
                dp[i][j] += dp[i-1][j-1] * (n-j+1)
                dp[i][j] += dp[i-1][j] * max(j-k, 0)
                dp[i][j] %= mod
        return dp[m][n]
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。