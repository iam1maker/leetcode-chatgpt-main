题目编号：955

题目：删列造序 II

难度：中等

考察范围：贪心算法、字符串处理

题干：给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。

删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。

比如，有 A = ["abcdef", "uvwxyz"]，

要删除的列为 {0, 2, 3}，删除后 A 为["bef", "vyz"]。

假设，我们选择了一组要删掉的列 D，在执行删除操作之后，A 中剩余的每一列都是 非降序排列 的，那么我们称作这一组删除操作是 成功的。

请你找到一个失败的删除操作。

解题思路：贪心算法

首先，我们需要明确一点，如果要删除的列中有一列不满足非降序排列，那么这一组删除操作一定是失败的。

因此，我们可以先遍历一遍 A 数组，找到所有不满足非降序排列的列，将这些列的下标保存下来。

接着，我们需要考虑如何进行删除操作，使得剩余的每一列都是非降序排列。

我们可以从左到右遍历每一列，如果当前列不满足非降序排列，那么我们就需要删除这一列。

但是，如果我们直接删除这一列，可能会导致后面的列不满足非降序排列，因此我们需要考虑一下如何保证后面的列仍然是非降序排列。

我们可以将当前列中不满足非降序排列的字符删除，然后再判断后面的列是否满足非降序排列。

如果后面的列仍然是非降序排列，那么我们就可以继续删除下一列，直到所有不满足非降序排列的列都被删除为止。

如果后面的列不满足非降序排列，那么这一组删除操作就是失败的。

解决方案：

```python
class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        # 找到所有不满足非降序排列的列
        delete_cols = set()
        for i in range(len(A[0])):
            for j in range(1, len(A)):
                if A[j][i] < A[j-1][i]:
                    delete_cols.add(i)
                    break
        
        # 从左到右遍历每一列，进行删除操作
        for i in range(len(A[0])):
            if i in delete_cols:
                continue
            for j in range(1, len(A)):
                if A[j][i] < A[j-1][i]:
                    delete_cols.add(i)
                    break
        
        return len(delete_cols)
```

算法复杂度：时间复杂度为 O(nm)，其中 n 是 A 数组的长度，m 是每个字符串的长度。空间复杂度为 O(m)。