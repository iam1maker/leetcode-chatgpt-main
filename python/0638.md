题目编号：638

题目：大礼包

难度：中等

考察范围：动态规划、回溯算法

题干：在LeetCode商店中， 有许多在售的物品。
LeetCode 想要开展一个促销活动，其中，需要使用一些大礼包，你需要设计一个算法，计算出最少需要购买多少套大礼包，才能将所需的所有物品都购买到，如果不能购买到所有的物品，则返回 -1。

大礼包
每个大礼包由一些列下列组成：
大礼包的价格 p，以及里面包含的物品的数量 cnt。
对于每个物品，你都可以按照单价购买，也可以忽略不计。
你需要输出确保购买到所有所需物品的最低花费。

示例 1:
输入: [2,5],[3,4],[1,2],[2,3],[4,1]
输出: 12
解释: 购买 2 套大礼包，第 1 套大礼包包含 [1,2]，第 2 套大礼包包含 [2,3] 和 [4,1]。
购买价格为 2*5 + 4*3 = 10 + 12 = 22。
但是如果不购买大礼包，单买价格为 2*5 + 3*4 + 1*2 + 2*3 + 4*1 = 10 + 12 + 2 + 6 + 4 = 34。

解题思路：动态规划

首先，我们可以将大礼包看成一个物品，这个物品的价格是大礼包的价格，数量是1，然后将大礼包中的物品看成单价为0的物品，这样就可以将大礼包和物品统一起来了。

接下来，我们可以使用动态规划来解决这个问题。我们定义一个一维数组 dp，其中 dp[i] 表示购买 i 这么多物品所需的最小花费。对于每个大礼包，我们可以将其拆分成单个物品，然后更新 dp 数组。具体来说，对于每个大礼包，我们可以枚举购买这个大礼包的数量 k，然后用 dp[i - cnt[j] * k] + k * price[j] 来更新 dp[i]，其中 cnt[j] 表示第 j 个大礼包中物品的数量，price[j] 表示第 j 个大礼包的价格。

最终，dp[n] 就是我们要求的答案，其中 n 表示需要购买的物品数量。

解决方案：

```python
class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        n = len(price)
        # 将大礼包看成一个物品，这个物品的价格是大礼包的价格，数量是1
        price = price + [0]
        for i in range(len(special)):
            special[i] = special[i] + [1]
        # 定义一个一维数组 dp，其中 dp[i] 表示购买 i 这么多物品所需的最小花费
        dp = [float('inf')] * (sum(needs) + 1)
        dp[0] = 0
        # 动态规划
        for i in range(1, sum(needs) + 1):
            for j in range(n + 1):
                if i >= j:
                    dp[i] = min(dp[i], dp[i - j] + price[j])
            for s in special:
                if i >= s[:-1]:
                    dp[i] = min(dp[i], dp[i - s[:-1]] + s[-1])
        return dp[sum(needs)]
```

算法复杂度：时间复杂度为 O(n^m)，其中 n 表示物品的数量，m 表示大礼包的数量。空间复杂度为 O(sum(needs))。