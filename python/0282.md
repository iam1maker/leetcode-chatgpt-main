题目编号：282

题目：给表达式添加运算符

难度：困难

考察范围：回溯算法、字符串处理

题干：

给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加二元运算符（不是一元）+、- 或 *，返回所有能够得到目标值的表达式。

示例 1:

输入: nums = "123", target = 6
输出: ["1+2+3", "1*2*3"] 

示例 2:

输入: nums = "232", target = 8
输出: ["2*3+2", "2+3*2"]

示例 3:

输入: nums = "105", target = 5
输出: ["1*0+5","10-5"]

示例 4:

输入: nums = "00", target = 0
输出: ["0+0", "0-0", "0*0"]

提示：

1. 0 <= nums.length <= 10
2. 通过次数29,862提交次数63,684

解题思路：

这道题可以使用回溯算法来解决。回溯算法是一种暴力搜索的算法，它通过不断地尝试所有可能的解决方案来找到最优解。在这道题中，我们需要枚举所有可能的表达式，然后计算它们的值，如果等于目标值，就将它们加入到结果集中。

具体来说，我们可以使用一个递归函数来实现回溯算法。在递归函数中，我们需要维护当前表达式的值、上一个数字、上一个运算符和当前位置。对于每个位置，我们可以选择将它作为一个新的数字，或者将它与上一个数字组成一个新的数字。对于每个数字，我们可以选择将它与上一个数字相加、相减或相乘。如果当前位置已经到达字符串的末尾，我们就可以计算当前表达式的值，如果等于目标值，就将它加入到结果集中。

解决方案：

```python
class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        def backtrack(expr, i, res, mul):
            if i == n:
                if res == target:
                    ans.append(expr)
                return
            for j in range(i + 1, n + 1):
                val = int(num[i:j])
                if i == 0:
                    backtrack(expr + str(val), j, val, val)
                else:
                    backtrack(expr + "+" + str(val), j, res + val, val)
                    backtrack(expr + "-" + str(val), j, res - val, -val)
                    backtrack(expr + "*" + str(val), j, res - mul + mul * val, mul * val)
        n = len(num)
        ans = []
        if n == 0:
            return ans
        backtrack("", 0, 0, 0)
        return ans
```

算法复杂度：时间复杂度为 O(4^n)，其中 n 是字符串的长度。回溯算法的时间复杂度一般都是指数级别的，因为它需要枚举所有可能的解决方案。在这道题中，我们需要枚举所有可能的表达式，每个表达式最多有 n 个数字和 n-1 个运算符，因此总共有 4^n 种可能的表达式。空间复杂度为 O(n)，其中 n 是字符串的长度。回溯算法的空间复杂度主要取决于递归栈的深度，递归栈的深度最多为 n。