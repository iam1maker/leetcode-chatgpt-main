题目编号：927

题目：三等分

难度：困难

考察范围：数组、双指针

题干：给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。

如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：

A[0], A[1], ..., A[i] 组成第一部分；
A[i+1], A[i+2], ..., A[j-1] 作为第二部分；
A[j], A[j+1], ..., A[A.length - 1] 是第三部分。
这三个部分所表示的二进制值相等。如果无法做到，就返回 [-1, -1]。

注意，在考虑每个部分所表示的二进制值时，应将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。

解题思路：首先统计数组中1的个数，如果1的个数不是3的倍数，那么无法分成三等分，直接返回[-1,-1]。如果1的个数为0，那么可以分成三个空数组，返回[0,2]。接下来，我们需要找到三个部分的起始和结束位置，使得它们所表示的二进制值相等。我们可以使用双指针的方法，首先找到第一个1的位置，然后从这个位置开始，向后遍历数组，每遇到一个1，就将计数器加1，当计数器等于1/3和2/3的1的个数时，记录当前位置，继续向后遍历，当计数器等于1/3和2/3的1的个数时，记录当前位置，最后判断三个部分所表示的二进制值是否相等即可。

解决方案：

```python
class Solution:
    def threeEqualParts(self, A: List[int]) -> List[int]:
        ones = sum(A)
        if ones % 3 != 0:
            return [-1, -1]
        if ones == 0:
            return [0, 2]
        k = ones // 3
        i = j = None
        cnt = 0
        for idx, val in enumerate(A):
            if val == 1:
                cnt += 1
                if cnt == 1:
                    i = idx
                elif cnt == k + 1:
                    j = idx
                elif cnt == 2 * k + 1:
                    break
        while j < len(A) and A[i] == A[j] == A[idx]:
            i += 1
            j += 1
            idx += 1
        if j == len(A):
            return [i-1, idx]
        else:
            return [-1, -1]
```

算法复杂度：时间复杂度为O(n)，空间复杂度为O(1)。