题目编号：60

题目：第k个排列

难度：中等

考察范围：数学、回溯算法

题干：

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。

示例 1:

输入: n = 3, k = 3
输出: "213"

示例 2:

输入: n = 4, k = 9
输出: "2314"

解题思路：

本题可以使用回溯算法来解决，但是时间复杂度较高，不太适合本题的数据范围。因此，我们需要寻找一种更加高效的解法。

我们可以通过数学的方法来解决本题。首先，我们可以将所有的排列按照第一个数字的大小进行分类，每一类中有 (n-1)! 个排列。因此，我们可以通过 k/(n-1)! 来确定第一个数字的大小，然后将 k 对 (n-1)! 取余，得到剩下的数字的排列顺序。然后，我们可以继续按照上述方法确定第二个数字的大小，以此类推，直到确定了所有的数字。

解决方案：

```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        # 计算阶乘
        factorials = [1]
        for i in range(1, n):
            factorials.append(factorials[-1] * i)

        # 将数字转化为字符串
        nums = [str(i) for i in range(1, n+1)]

        # 计算每个数字的排列顺序
        k -= 1
        res = []
        for i in range(n-1, -1, -1):
            index = k // factorials[i]
            k %= factorials[i]
            res.append(nums[index])
            nums.pop(index)

        return ''.join(res)
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。