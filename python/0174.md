题目编号：174

题目：地下城游戏

难度：困难

考察范围：动态规划

题干：

给定一个包含非负整数的 m x n 网格 dungeon ，请你计算出从左上角到右下角的最小初始健康点数。

开始时，你的健康点数为一个整数，你的任务是通过消耗一定的健康点数来支持你的旅程。你可以从左上角开始，也可以从右下角开始。

每个格子要么是空的，要么是包含一个怪物。每个格子都保证至少存在一条通往右下角的路径。你每次可以向下或向右移动。

在任意时刻，你的健康点数都不能少于 1 。如果你的健康点数小于等于 0 ，你将立即死亡。

示例 1：

输入：dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
输出：7
解释：
初始点数为 1 ，最佳路径为 [1,3,5,0,3,1,1] ，最终点数为 7 。

示例 2：

输入：dungeon = [[0]]
输出：1

解题思路：

这道题可以使用动态规划来解决。我们可以从右下角开始往左上角推导，设 dp[i][j] 表示从 (i,j) 到右下角所需的最小初始健康点数。那么我们可以得到以下状态转移方程：

dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)

其中，min(dp[i+1][j], dp[i][j+1]) 表示从 (i,j) 出发，向右或向下走所需的最小初始健康点数。而 dungeon[i][j] 表示当前格子所需的健康点数。我们需要用 min(dp[i+1][j], dp[i][j+1]) 减去 dungeon[i][j]，得到从 (i,j) 出发所需的最小初始健康点数。但是，如果这个值小于等于 0，那么我们就需要将其设为 1，因为我们的健康点数不能小于 1。

最终，dp[0][0] 就是从左上角到右下角所需的最小初始健康点数。

解决方案：

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        dp = [[0] * n for _ in range(m)]
        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])
        for i in range(m-2, -1, -1):
            dp[i][-1] = max(1, dp[i+1][-1] - dungeon[i][-1])
        for j in range(n-2, -1, -1):
            dp[-1][j] = max(1, dp[-1][j+1] - dungeon[-1][j])
        for i in range(m-2, -1, -1):
            for j in range(n-2, -1, -1):
                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])
        return dp[0][0]
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。