题目编号：452

题目：用最少数量的箭引爆气球

难度：中等

考察范围：贪心算法

题干：

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，因此y坐标并不重要，因此输入是一个二维数组points，其中points[i] = [xstart, xend]表示第i个气球的直径在x轴上的开始和结束坐标。可能存在气球重叠，求至少需要多少个箭头才能将所有气球都刺破。

示例1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于两个区间[1,6]和[7,12]，它们共用一支箭，因此可以将它们合并为[1,12]，这样只需要一支箭就可以将所有气球刺破。

示例2：

输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4

解释：因为气球的直径互不相同，所以需要4支箭，分别对应每个气球。

解题思路：

本题可以使用贪心算法来解决。首先将气球按照结束坐标从小到大排序，然后从第一个气球开始，记录当前箭头的位置为第一个气球的结束坐标。接着遍历每个气球，如果当前气球的开始坐标小于等于当前箭头的位置，则说明这个气球可以和前面的气球一起被刺破，不需要额外的箭头。否则，说明这个气球和前面的气球没有重叠，需要额外的箭头。此时，将当前箭头的位置更新为当前气球的结束坐标，继续遍历下一个气球。最后，记录使用的箭头数量即可。

解决方案：

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        # 按照结束坐标从小到大排序
        points.sort(key=lambda x: x[1])
        # 初始化箭头位置为第一个气球的结束坐标
        arrow_pos = points[0][1]
        arrow_cnt = 1
        for i in range(1, len(points)):
            # 如果当前气球的开始坐标小于等于当前箭头的位置，则不需要额外的箭头
            if points[i][0] <= arrow_pos:
                continue
            # 否则，需要额外的箭头，将箭头位置更新为当前气球的结束坐标
            arrow_pos = points[i][1]
            arrow_cnt += 1
        return arrow_cnt
```

算法复杂度：时间复杂度为O(nlogn)，其中n为气球的数量，主要是排序的时间复杂度；空间复杂度为O(1)，只需要常数级别的额外空间。