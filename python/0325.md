题目编号：325

题目：和等于 k 的最长子数组长度

难度：中等

考察范围：数组、哈希表

题干：

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的最长的连续子数组的长度。

示例 1:

输入: nums = [1, -1, 5, -2, 3], k = 3
输出: 4
解释: 子数组 [1, -1, 5, -2] 和等于 3，且长度最长。

说明:
数组长度的范围在 [1, 20,000]。
数组中元素的范围在 [-1000, 1000]，且整数 k 的范围在 [-1e7, 1e7]。

解题思路：

本题可以使用哈希表来解决，具体思路如下：

1. 定义一个哈希表，用于存储前缀和及其对应的下标；
2. 定义一个变量 sum，用于记录当前的前缀和；
3. 遍历数组，计算当前的前缀和 sum，并判断是否存在 sum - k 的前缀和；
4. 如果存在，则说明从该前缀和对应的下标到当前下标的子数组和为 k，更新最长子数组长度；
5. 如果不存在，则将当前前缀和及其对应的下标存入哈希表中。

解决方案：

```python
class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -> int:
        # 定义哈希表，用于存储前缀和及其对应的下标
        hashmap = {0: -1}
        # 定义变量 sum，用于记录当前的前缀和
        sum = 0
        # 定义变量 max_len，用于记录最长子数组长度
        max_len = 0
        # 遍历数组
        for i in range(len(nums)):
            # 计算当前的前缀和
            sum += nums[i]
            # 判断是否存在 sum - k 的前缀和
            if sum - k in hashmap:
                # 更新最长子数组长度
                max_len = max(max_len, i - hashmap[sum - k])
            # 如果不存在，则将当前前缀和及其对应的下标存入哈希表中
            if sum not in hashmap:
                hashmap[sum] = i
        return max_len
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。