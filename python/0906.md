题目编号：906

题目：超级回文数

难度：困难

考察范围：回文数、数学

题干：

如果一个正整数是回文，那么就称它是 超级回文数 。

现有一个给定的正整数，请你返回将它变成超级回文数所需的最小步数。

如果无法将其变成超级回文数，请返回 -1 。

超级回文数「是回文数且同时满足下述条件：」

    正整数的所有数字的平方都是回文数。
    超级回文数是一个回文数。

示例 1：

输入：n = "4"
输出：4
解释：步骤如下：
"4" -> "16" -> "256" -> "65536" -> "65656556"

示例 2：

输入：n = "1"
输出：0
解释："1" 已经是超级回文数。

解题思路：

首先，我们可以发现，一个回文数的后一半一定是前一半的翻转，例如 12321，后一半 321 就是前一半 123 的翻转。

其次，我们可以发现，一个回文数的长度一定是偶数或者奇数，例如 12321 的长度是奇数，而 1221 的长度是偶数。

接着，我们可以发现，一个回文数的平方的后一半也是前一半的翻转，例如 121 的平方是 14641，后一半 641 就是前一半 41 的翻转。

最后，我们可以发现，一个回文数的平方的长度一定是奇数，例如 11 的平方是 121，长度是奇数。

综上所述，我们可以得到以下结论：

- 超级回文数的长度一定是偶数，因为一个奇数长度的回文数的平方的长度一定是偶数，不可能是超级回文数。
- 超级回文数的范围是 [1, 10^9]，因为 10^18 的平方已经超过了 int 的范围。
- 我们只需要枚举前一半的数字，然后构造出后一半的数字，再计算它的平方，判断是否是回文数即可。

解决方案：

```python
class Solution:
    def superpalindromesInRange(self, left: str, right: str) -> int:
        left, right = int(left), int(right)
        ans = 0
        for i in range(1, 10000):
            s = str(i)
            t = s + s[-2::-1] # 构造出回文数的后一半
            v = int(t) ** 2
            if v > right:
                break
            if v >= left and str(v) == str(v)[::-1] and str(i) == str(i)[::-1]:
                ans += 1
        for i in range(1, 10000):
            s = str(i)
            t = s + s[::-1] # 构造出回文数的后一半
            v = int(t) ** 2
            if v > right:
                break
            if v >= left and str(v) == str(v)[::-1] and str(i) == str(i)[::-1]:
                ans += 1
        return ans
```

算法复杂度：时间复杂度为 O(√n)，空间复杂度为 O(1)。其中，n 是 right 的值。