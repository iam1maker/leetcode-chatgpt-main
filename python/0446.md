题目编号：446

题目：等差数列划分 II - 子序列

难度：困难

考察范围：动态规划

题干：

给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。

如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
再例如，[1, 1, 2, 5, 7] 不是等差序列。
数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。

例如，[2,5,10] 是 [1,2,1,2,4,1,5,7,8,10] 的一个子序列。

题解思路：

本题是一道动态规划的题目，我们可以使用 dp[i][j] 表示以 nums[i] 和 nums[j] 为结尾的等差子序列的个数。其中，i < j，且 nums[j] - nums[i] = d，d 表示公差。

对于每个 j，我们枚举它之前的所有位置 i，计算以 nums[i] 和 nums[j] 为结尾，公差为 d 的等差子序列个数。由于公差不一定是整数，我们可以使用哈希表来记录之前的位置中，公差为 d 的位置个数。

具体地，我们首先将所有位置作为结尾的等差子序列个数初始化为 0。对于每个位置 j，我们将之前的位置 i 分成两类：

- i 与 j 位置的元素相同；
- i 与 j 位置的元素不同。

对于第一类位置 i，我们可以得到公差为 0，长度大于等于 2 的等差子序列，它们对答案的贡献为 dp[i][j] += dp[i][j] + 1。

对于第二类位置 i，我们可以得到公差不为 0，长度大于等于 2 的等差子序列，它们对答案的贡献为 dp[i][j] += dp[k][i]，其中 k 表示公差为 d，且位置在 i 之前的位置。

最终，所有位置作为结尾的等差子序列个数之和即为所求。

解决方案：

```python
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        dp = [collections.defaultdict(int) for _ in range(n)]
        for i in range(n):
            for j in range(i):
                d = nums[i] - nums[j]
                cnt = dp[j][d]
                ans += cnt
                dp[i][d] += cnt + 1
        return ans
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。