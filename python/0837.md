题目编号：837

题目：新21点

难度：中等

考察范围：动态规划

题干：爱丽丝参与一个大致基于纸牌游戏 “21 点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从牌顶抽一张牌，将其点数添加到自己的得分中。 每张牌都有其对应的点数，J、Q、K 的点数为 10，A 的点数为 1 或 11（选择使得爱丽丝的点数不超过 K），牌面数字直接对应其点数。爱丽丝有一些策略可以帮助她在游戏中获胜：

- 如果她的得分不超过 K，她将自己的得分与黑桃 A 的点数相加。此时，她可以选择将黑桃 A 的点数计为 1 或 11 点。
- 如果她的得分大于 K，她就会输掉游戏。

写一个函数，求出爱丽丝能够获胜的概率，精确到小数点后 5 位。

解题思路：动态规划

我们可以用 dp[x] 表示当前得分为 x 时，能否获胜。显然，当得分为 K 时，游戏结束，dp[K] = 1；当得分大于 K 时，游戏结束，dp[x] = 0；当得分小于 K 时，我们需要计算 dp[x] 的值。

对于当前的得分 x，我们可以抽到的牌的点数为 1 到 W，因此有：

dp[x] = \frac{1}{W} \sum_{i=1}^{W} dp[x+i]

其中，dp[x+i] 表示抽到点数为 i 的牌后，得分变为 x+i 时，对手的胜率。因为对手也是按照同样的规则进行游戏，所以对手的胜率可以表示为 dp[x+i]。

最终，我们需要求的是 dp[0]，即初始得分为 0 时，能否获胜的概率。

解决方案：

```python
class Solution:
    def new21Game(self, N: int, K: int, W: int) -> float:
        if K == 0:
            return 1.0
        dp = [0.0] * (K + W)
        for i in range(K, K + W):
            dp[i] = 1.0 if i <= N else 0.0
        dp[K - 1] = 1.0 * min(N - K + 1, W) / W
        for i in range(K - 2, -1, -1):
            dp[i] = dp[i + 1] - (dp[i + W + 1] - dp[i + 1]) / W
        return dp[0]
```

算法复杂度：时间复杂度为 O(N+W)，空间复杂度为 O(N+W)。