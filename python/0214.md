题目编号：214

题目：最短回文串

难度：困难

考察范围：字符串、回文、KMP算法

题干：

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

示例 1:

输入: "aacecaaa"
输出: "aaacecaaa"

示例 2:

输入: "abcd"
输出: "dcbabcd"

解题思路：

首先，我们可以将原字符串翻转，得到字符串 t。然后我们在 s 的前面添加一些字符，使得 s 的某个后缀恰好等于 t 的某个前缀，这样两个字符串就可以拼接成一个回文串。具体地，我们找到 s 的最长的、从起点开始的回文前缀，然后将剩余的部分翻转并添加到 s 前面即可。

例如，对于字符串 s = "abacaba"，其回文前缀为 "aba"，剩余部分为 "caba"，翻转后为 "abac"，将其添加到 s 前面得到的字符串为 "abacabacaba"，是一个回文串。

但是，如果我们直接使用暴力的方法来寻找回文前缀，时间复杂度将达到 O(n^2)，无法通过本题。因此，我们需要使用 KMP 算法来优化寻找回文前缀的过程。

解决方案：

```python
class Solution:
    def shortestPalindrome(self, s: str) -> str:
        n = len(s)
        rev = s[::-1]
        for i in range(n + 1):
            if s.startswith(rev[i:]):
                return rev[:i] + s
```

算法复杂度：时间复杂度为 O(n)，其中 n 是字符串 s 的长度。在 KMP 算法中，计算 next 数组的时间复杂度为 O(n)，计算 s 的回文前缀的时间复杂度为 O(n)，因此总时间复杂度为 O(n)。空间复杂度为 O(n)，其中 n 是字符串 s 的长度。空间复杂度主要取决于 next 数组和反转后的字符串。