题目编号：870

题目：优势洗牌

难度：中等

考察范围：数组、排序、贪心算法

题干：给定两个长度相等的整数数组 A 和 B，其中 A[i] 和 B[i] 都是第 i 个元素的值。请你根据以下规则返回一个新的数组 C：

C[i] 是 A 中的第 i 小的元素在 B 中的出现次数。
C 的顺序必须与 A 的严格递增顺序相同。
示例 1：

输入：
A = [2,7,11,15], B = [1,10,4,11]
输出：[2,0,2,1]
解释：
A 中的元素分别是 2、7、11 和 15，按从小到大的顺序排列。
B 中的元素分别是 1、10、4 和 11，对应的出现次数为 0、2、1 和 2。
因此，C = [2,0,2,1]。

解题思路：首先将 A 和 B 按照从小到大的顺序排序，然后从大到小遍历 A，对于每个 A[i]，在 B 中找到最小的大于 B[j] 的数，将其加入结果数组 C 中，并将 B[j] 标记为已使用。如果没有找到大于 A[i] 的数，则在 B 中找到最小的数加入结果数组 C 中，并将其标记为已使用。

解决方案：

```python
class Solution:
    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        n = len(A)
        A.sort()
        B = [(B[i], i) for i in range(n)]
        B.sort()
        C = [-1] * n
        i, j = 0, n - 1
        for k in range(n - 1, -1, -1):
            if A[j] > B[k][0]:
                C[B[k][1]] = A[j]
                j -= 1
            else:
                C[B[k][1]] = A[i]
                i += 1
        return C
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。