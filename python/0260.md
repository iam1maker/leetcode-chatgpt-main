题目编号：260

题目：只出现一次的数字 III

难度：中等

考察范围：位运算

题干：

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按任意顺序返回答案。

进阶：你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？

示例 1：

输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。

示例 2：

输入：nums = [-1,0]
输出：[-1,0]

示例 3：

输入：nums = [0,1]
输出：[1,0]

解题思路：

由于只有两个元素只出现一次，其余元素均出现两次，因此可以考虑将所有元素异或起来，得到的结果就是这两个只出现一次的元素的异或结果。

由于这两个元素不相同，因此它们的异或结果一定不为 0，也就是说在这个结果中至少有一位是 1。我们可以根据这一位是否为 1，将原数组中的元素分成两个部分，分别异或得到两个只出现一次的元素。

具体来说，假设两个只出现一次的元素分别为 a 和 b，那么我们可以先对所有数字进行一次异或，得到的结果为 x = a ⊕ b，其中 ⊕ 表示异或运算。x 中至少存在一位 1，我们找到其中任意一位为 1 的位，以第 i 位为分界线，将原数组分成两部分。对于其中一部分，我们取所有元素的第 i 位都为 0，对于另外一部分，我们取所有元素的第 i 位都为 1。由于这样分割之后，a 和 b 会被分到不同的部分，因此我们分别对两个部分进行异或操作，即可得到 a 和 b。

解决方案：

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        # 对所有数字进行一次异或，得到的结果为 x = a ⊕ b
        x = 0
        for num in nums:
            x ^= num
        
        # 找到 x 中任意一位为 1 的位
        div = 1
        while div & x == 0:
            div <<= 1
        
        # 根据该位是否为 1 将原数组分成两个部分，分别异或得到 a 和 b
        a, b = 0, 0
        for num in nums:
            if div & num == 0:
                a ^= num
            else:
                b ^= num
        
        return [a, b]
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。