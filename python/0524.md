题目编号：524

题目：通过删除字母匹配到字典里最长单词

难度：中等

考察范围：字符串、排序、双指针

题干：

给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串中的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果没有，则返回空字符串。

示例 1:

输入:
s = "abpclefs"
d = ["ale","apple","monkey","plea"]

输出: 
"apple"

示例 2:

输入:
s = "abpclefs"
d = ["a","b","c"]

输出: 
"a"

解题思路：

首先，我们需要对字典中的字符串按照长度和字典序进行排序，这样可以方便后面的匹配。

然后，我们遍历字典中的每个字符串，判断该字符串是否可以通过删除给定字符串中的某些字符来得到。具体来说，我们可以使用双指针的方法，分别从给定字符串和字典中的字符串的开头开始遍历，如果两个字符相等，则两个指针都向后移动一位；否则，只移动给定字符串的指针。如果字典中的字符串的指针移动到了末尾，则说明该字符串可以通过删除给定字符串中的某些字符来得到。

最后，我们返回长度最长且字典序最小的字符串即可。

解决方案：

```python
class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        # 对字典中的字符串按照长度和字典序进行排序
        d.sort(key=lambda x: (-len(x), x))
        # 遍历字典中的每个字符串
        for word in d:
            i, j = 0, 0
            # 使用双指针的方法判断该字符串是否可以通过删除给定字符串中的某些字符来得到
            while i < len(s) and j < len(word):
                if s[i] == word[j]:
                    j += 1
                i += 1
            if j == len(word):
                return word
        return ""
```

算法复杂度：时间复杂度为 O(nlogn + nm)，其中 n 是字典中字符串的个数，m 是给定字符串的长度。排序的时间复杂度为 O(nlogn)，遍历字典中的每个字符串的时间复杂度为 O(nm)。空间复杂度为 O(logn)，即排序的空间复杂度。