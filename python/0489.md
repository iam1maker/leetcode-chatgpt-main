题目编号：489

题目：机器人清扫器

难度：困难

考察范围：深度优先搜索、模拟

题干：给定一个机器人在一个无限大小的网格上行走。网格有一些障碍物，机器人不能走到障碍物上。

设计一个算法，实现机器人清除所有的障碍物。

机器人的初始位置为 (0, 0)。当它向北走时，位置变为 (x, y+1)；向南走时，位置变为 (x, y-1)；向西走时，位置变为 (x-1, y)；向东走时，位置变为 (x+1, y)。

机器人会收到三个可能的动作：

- -2：向左转 90 度
- -1：向右转 90 度
- 1 <= k <= 100：向前移动 k 个单位长度

如果机器人在完成动作后仍然在网格中，则继续执行下一动作。

示例 1:

输入: 
grid = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]

输出: 3
解释: 
起始位置是 (0, 0)，机器人将会移动到 (0, 1)，然后移动到 (0, 2)，接着移动到 (0, 3)，然后移动到 (1, 3)，接着移动到 (2, 3)，然后移动到 (3, 3)，接着移动到 (3, 2)，接着移动到 (3, 1)，接着移动到 (3, 0)，接着移动到 (2, 0)，接着移动到 (1, 0)，接着移动到 (0, 0)，清除了 3 个障碍物。

解题思路：本题可以使用深度优先搜索（DFS）来解决。首先需要找到机器人的初始位置，然后从该位置开始进行DFS搜索。在搜索过程中，需要记录机器人的位置和方向，以及已经清除的障碍物数量。每次搜索时，先判断当前位置是否为障碍物或者已经访问过，如果是则返回；否则，将当前位置标记为已访问，并尝试向当前方向前进。如果前进后的位置不是障碍物且没有访问过，则继续向前搜索；否则，机器人需要向左或向右转向，并继续搜索。当机器人完成所有动作后，返回已经清除的障碍物数量即可。

解决方案：

```python
class Solution:
    def cleanRoom(self, robot):
        """
        :type robot: Robot
        :rtype: None
        """
        # 定义方向数组，分别表示向上、右、下、左四个方向
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        # 定义已访问的位置集合
        visited = set()
        
        def dfs(x, y, direction):
            # 标记当前位置已访问
            robot.clean()
            visited.add((x, y))
            # 尝试向当前方向前进
            for i in range(4):
                # 计算下一个位置的坐标
                dx, dy = directions[direction]
                nx, ny = x + dx, y + dy
                # 如果下一个位置没有访问过且不是障碍物，则继续向前搜索
                if (nx, ny) not in visited and robot.move():
                    dfs(nx, ny, direction)
                    # 回溯到上一个位置
                    robot.turnRight()
                    robot.turnRight()
                    robot.move()
                    robot.turnRight()
                    robot.turnRight()
                # 否则，机器人需要向左或向右转向
                robot.turnRight()
                direction = (direction + 1) % 4
        
        # 从初始位置开始搜索
        dfs(0, 0, 0)
``` 

算法复杂度：本算法的时间复杂度为 O(nm)，其中 n 和 m 分别为网格的行数和列数。空间复杂度为 O(nm)，主要用于存储已访问的位置。