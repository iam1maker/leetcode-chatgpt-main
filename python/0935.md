题目编号：935

题目：骑士拨号器

难度：中等

考察范围：递归、动态规划

题干：国际象棋中的骑士可以按下图所示进行移动：

![image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/11/03/knight.png)

这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，他将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，所以输出答案模 10^9 + 7。

解题思路：本题可以使用递归或动态规划来解决。递归的思路是从每个数字键开始，向8个方向递归，直到跳完N-1步，统计不同的号码数。动态规划的思路是从1步开始，逐步计算出2步、3步、...、N步的不同号码数，最终得到N步的不同号码数。

解决方案：这里给出动态规划的解法。

```python
class Solution:
    def knightDialer(self, N: int) -> int:
        # 定义数字键盘的邻接矩阵
        graph = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]
        # 定义动态规划数组dp[i][j]表示从数字键j出发跳i步的不同号码数
        dp = [[0]*10 for _ in range(N)]
        # 初始化dp数组，从每个数字键出发跳1步的不同号码数都为1
        for i in range(10):
            dp[0][i] = 1
        # 逐步计算出2步、3步、...、N步的不同号码数
        for i in range(1, N):
            for j in range(10):
                for k in graph[j]:
                    dp[i][j] += dp[i-1][k]
                dp[i][j] %= 1000000007
        # 统计N步的不同号码数
        res = 0
        for i in range(10):
            res += dp[N-1][i]
        return res % 1000000007
```

算法复杂度：时间复杂度为O(N)，空间复杂度为O(N)。